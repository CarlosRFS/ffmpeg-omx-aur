From 0516f97c48efe43f7122b581e68d261caf2527cd Mon Sep 17 00:00:00 2001
From: Carlos Raimundo de Freitas Sotero <carlosrfs99@gmail.com>
Date: Sun, 1 Oct 2023 16:37:44 -0300
Subject: [PATCH 3/6] bug fix to omx hevc encoder on ffmpeg n6.0 based on
 starfive tech patches:
 https://github.com/starfive-tech/Debian/tree/20221225T084846Z/multimedia/patch/ffmpeg

---
 libavcodec/omx.c | 23 +++++++++++++++++++++--
 1 file changed, 21 insertions(+), 2 deletions(-)

diff --git a/libavcodec/omx.c b/libavcodec/omx.c
index 688540cea5..1f900e14b8 100644
--- a/libavcodec/omx.c
+++ b/libavcodec/omx.c
@@ -43,6 +43,7 @@
 #include "avcodec.h"
 #include "codec_internal.h"
 #include "h264.h"
+#include "hevc.h"
 #include "pthread_internal.h"
 #include "profiles.h"
 
@@ -481,9 +482,11 @@ static av_cold int omx_component_init(AVCodecContext *avctx, const char *role)
     in_port_params.format.video.nFrameWidth  = avctx->width;
     in_port_params.format.video.nFrameHeight = avctx->height;
     if (avctx->framerate.den > 0 && avctx->framerate.num > 0)
-        in_port_params.format.video.xFramerate = (1LL << 16) * avctx->framerate.num / avctx->framerate.den;
+        //in_port_params.format.video.xFramerate = (1LL << 16) * avctx->framerate.num / avctx->framerate.den;
+        in_port_params.format.video.xFramerate = avctx->framerate.num / avctx->framerate.den;
     else
-        in_port_params.format.video.xFramerate = (1LL << 16) * avctx->time_base.den / avctx->time_base.num;
+        //in_port_params.format.video.xFramerate = (1LL << 16) * avctx->time_base.den / avctx->time_base.num;
+        in_port_params.format.video.xFramerate = avctx->time_base.den / avctx->time_base.num;
 
     err = OMX_SetParameter(s->handle, OMX_IndexParamPortDefinition, &in_port_params);
     CHECK(err);
@@ -721,6 +724,22 @@ static av_cold int omx_encode_init(AVCodecContext *avctx)
                 }
                 if (nals[H264_NAL_SPS] && nals[H264_NAL_PPS])
                     break;
+            } else if {
+                // For H.265, the extradata can be returned in two separate buffers
+		// (the videocore encoder on raspberry pi does this);
+		// therefore check that we have got both SPS and PPS before continuing.
+                int nals[32] = { 0 };
+                int i;
+                for (i = 0; i + 4 < avctx->extradata_size; i++) {
+                     if (!avctx->extradata[i + 0] &&
+                         !avctx->extradata[i + 1] &&
+                         !avctx->extradata[i + 2] &&
+                         avctx->extradata[i + 3] == 1) {
+                         nals[(avctx->extradata[i + 4] & 0x7E) >> 1]++;
+                     }
+                }
+                if (nals[HEVC_NAL_SPS] && nals[HEVC_NAL_PPS] && nals[HEVC_NAL_VPS])
+                    break;
             } else {
                 if (avctx->extradata_size > 0)
                     break;
-- 
2.41.0

